// <auto-generated>
// This file was generated from the JSON Schema by quicktype.
// Do not edit manually. Run 'npm run generate' to regenerate.
// </auto-generated>

#nullable enable

namespace DynamicForms.FormValidation.Models
{
    using System;
    using System.Collections.Generic;

    using System.Text.Json;
    using System.Text.Json.Serialization;
    using System.Globalization;

    /// <summary>
    /// Complete form configuration
    /// </summary>
    public partial class FormConfig
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("autoSave")]
        public bool? AutoSave { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("autoSaveInterval")]
        public double? AutoSaveInterval { get; set; }

        [JsonPropertyName("fields")]
        public List<FormFieldConfig> Fields { get; set; }

        [JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// Label for save button (for use by consuming application)
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("saveLabel")]
        public string SaveLabel { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("sections")]
        public List<FormSection> Sections { get; set; }

        /// <summary>
        /// Label for submit button (for use by consuming application)
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("submitLabel")]
        public string SubmitLabel { get; set; }

        /// <summary>
        /// Wizard mode configuration - splits form into multi-page wizard
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("wizard")]
        public WizardConfig Wizard { get; set; }
    }

    /// <summary>
    /// Field configuration for dynamic form
    /// </summary>
    public partial class FormFieldConfig
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("archived")]
        public bool? Archived { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("asyncValidation")]
        public AsyncValidationConfig AsyncValidation { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("autocompleteConfig")]
        public AutocompleteConfig AutocompleteConfig { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("condition")]
        public ValidationCondition Condition { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("content")]
        public string Content { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("cssClass")]
        public string CssClass { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("datagridConfig")]
        public DataGridConfig DataGridConfig { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("daterangeConfig")]
        public DateRangeConfig DateRangeConfig { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("description")]
        public string Description { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("disabled")]
        public bool? Disabled { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("fileuploadConfig")]
        public FileUploadConfig FileUploadConfig { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("formrefConfig")]
        public FormRefConfig FormRefConfig { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("inlineGroup")]
        public string InlineGroup { get; set; }

        [JsonPropertyName("label")]
        public string Label { get; set; }

        [JsonPropertyName("name")]
        public string Name { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("options")]
        public List<SelectOption> Options { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("order")]
        public double? Order { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("phoneConfig")]
        public PhoneConfig PhoneConfig { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("placeholder")]
        public string Placeholder { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("sectionId")]
        public string SectionId { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("tableConfig")]
        public TableConfig TableConfig { get; set; }

        [JsonPropertyName("type")]
        public FieldType Type { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("validations")]
        public List<ValidationRule> Validations { get; set; }

        [JsonPropertyName("value")]
        public object Value { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("width")]
        public double? Width { get; set; }
    }

    /// <summary>
    /// Async validation configuration using named validator pattern Works across client and
    /// server by referencing registered validators
    /// </summary>
    public partial class AsyncValidationConfig
    {
        /// <summary>
        /// Debounce delay in milliseconds (default: 300) Only applies when trigger is 'change'
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("debounceMs")]
        public double? DebounceMs { get; set; }

        /// <summary>
        /// Optional parameters to pass to the async validator
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("params")]
        public Dictionary<string, object> Params { get; set; }

        /// <summary>
        /// Optional trigger for when validation should run
        /// - 'blur': Validate when field loses focus (default)
        /// - 'change': Validate on every change
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("trigger")]
        public Trigger? Trigger { get; set; }

        /// <summary>
        /// Name of the registered async validator Must be registered on both client and server
        /// </summary>
        [JsonPropertyName("validatorName")]
        public string ValidatorName { get; set; }
    }

    /// <summary>
    /// Result of async validation
    /// </summary>
    public class AsyncValidationResult
    {
        /// <summary>
        /// Whether the validation passed
        /// </summary>
        [JsonPropertyName("valid")]
        public bool Valid { get; set; }

        /// <summary>
        /// Optional error message when validation fails
        /// </summary>
        [JsonPropertyName("message")]
        public string? Message { get; set; }
    }

    /// <summary>
    /// Autocomplete field configuration
    /// </summary>
    public partial class AutocompleteConfig
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("debounceMs")]
        public double? DebounceMs { get; set; }

        [JsonPropertyName("fetchHandlerName")]
        public string FetchHandlerName { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("loadingMessage")]
        public string LoadingMessage { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("minSearchLength")]
        public double? MinSearchLength { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("noResultsMessage")]
        public string NoResultsMessage { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("params")]
        public Dictionary<string, object> Params { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("placeholder")]
        public string Placeholder { get; set; }
    }

    /// <summary>
    /// Condition that determines when a validation rule applies
    ///
    /// Optional condition that must be met for this validation to apply. If not specified,
    /// validation always applies.
    /// </summary>
    public partial class ValidationCondition
    {
        /// <summary>
        /// Field/column to evaluate.
        /// - For standalone fields: field name (e.g., "tenure")
        /// - For table columns: column name for same-row (e.g., "tenure")   or "$form.fieldName" for
        /// form-level fields (e.g., "$form.employmentType")
        /// </summary>
        [JsonPropertyName("field")]
        public string Field { get; set; }

        [JsonPropertyName("operator")]
        public ValidationConditionOperator Operator { get; set; }

        /// <summary>
        /// Value to compare against. Required for 'equals' and 'notEquals'. Ignored for 'isEmpty'
        /// and 'isNotEmpty'.
        /// </summary>
        [JsonPropertyName("value")]
        public object Value { get; set; }
    }

    /// <summary>
    /// DataGrid field configuration
    /// </summary>
    public partial class DataGridConfig
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("columnGroups")]
        public List<DataGridColumnGroup> ColumnGroups { get; set; }

        [JsonPropertyName("columns")]
        public List<DataGridColumnConfig> Columns { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("rowLabelHeader")]
        public string RowLabelHeader { get; set; }

        [JsonPropertyName("rowLabels")]
        public List<DataGridRowLabel> RowLabels { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("totals")]
        public DataGridTotalsConfig Totals { get; set; }
    }

    /// <summary>
    /// DataGrid column group configuration for two-tier headers
    /// </summary>
    public partial class DataGridColumnGroup
    {
        [JsonPropertyName("columnIds")]
        public List<string> ColumnIds { get; set; }

        [JsonPropertyName("id")]
        public string Id { get; set; }

        [JsonPropertyName("label")]
        public string Label { get; set; }
    }

    /// <summary>
    /// DataGrid column configuration
    /// </summary>
    public partial class DataGridColumnConfig
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("computed")]
        public bool? Computed { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("formula")]
        public DataGridFormula Formula { get; set; }

        [JsonPropertyName("label")]
        public string Label { get; set; }

        [JsonPropertyName("name")]
        public string Name { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("options")]
        public List<SelectOption> Options { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("placeholder")]
        public string Placeholder { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("showInColumnTotal")]
        public bool? ShowInColumnTotal { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("showInRowTotal")]
        public bool? ShowInRowTotal { get; set; }

        [JsonPropertyName("type")]
        public ColumnType Type { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("validations")]
        public List<ValidationRule> Validations { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("width")]
        public double? Width { get; set; }
    }

    /// <summary>
    /// Computed column formula configuration
    /// </summary>
    public partial class DataGridFormula
    {
        [JsonPropertyName("expression")]
        public string Expression { get; set; }

        [JsonPropertyName("type")]
        public TypeEnum Type { get; set; }
    }

    public partial class SelectOption
    {
        [JsonPropertyName("label")]
        public string Label { get; set; }

        [JsonPropertyName("value")]
        public object Value { get; set; }
    }

    /// <summary>
    /// Validation rule configuration
    /// </summary>
    public partial class ValidationRule
    {
        /// <summary>
        /// Optional condition that must be met for this validation to apply. If not specified,
        /// validation always applies.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("condition")]
        public ValidationCondition Condition { get; set; }

        /// <summary>
        /// Name of a registered custom validator (works on client and server)
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("customValidatorName")]
        public string CustomValidatorName { get; set; }

        /// <summary>
        /// Parameters to pass to the custom validator
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("customValidatorParams")]
        public Dictionary<string, object> CustomValidatorParams { get; set; }

        [JsonPropertyName("message")]
        public string Message { get; set; }

        [JsonPropertyName("type")]
        public ValidationRuleType Type { get; set; }

        [JsonPropertyName("value")]
        public object Value { get; set; }
    }

    /// <summary>
    /// DataGrid row label configuration
    /// </summary>
    public partial class DataGridRowLabel
    {
        [JsonPropertyName("id")]
        public string Id { get; set; }

        [JsonPropertyName("label")]
        public string Label { get; set; }
    }

    /// <summary>
    /// DataGrid totals configuration
    /// </summary>
    public partial class DataGridTotalsConfig
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("columnTotalLabel")]
        public string ColumnTotalLabel { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("rowTotalLabel")]
        public string RowTotalLabel { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("showColumnTotals")]
        public bool? ShowColumnTotals { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("showRowTotals")]
        public bool? ShowRowTotals { get; set; }
    }

    /// <summary>
    /// Date range field configuration
    /// </summary>
    public partial class DateRangeConfig
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("fromLabel")]
        public string FromLabel { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("separatorText")]
        public string SeparatorText { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("toDateOptional")]
        public bool? ToDateOptional { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("toLabel")]
        public string ToLabel { get; set; }
    }

    /// <summary>
    /// File upload field configuration
    /// </summary>
    public partial class FileUploadConfig
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("allowDownload")]
        public bool? AllowDownload { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("allowDragDrop")]
        public bool? AllowDragDrop { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("allowedExtensions")]
        public List<string> AllowedExtensions { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("allowedMimeTypes")]
        public List<string> AllowedMimeTypes { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("dragDropLabel")]
        public string DragDropLabel { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("maxFiles")]
        public double? MaxFiles { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("maxFileSize")]
        public double? MaxFileSize { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("minFileSize")]
        public double? MinFileSize { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("minFiles")]
        public double? MinFiles { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("showFileSize")]
        public bool? ShowFileSize { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("uploadButtonLabel")]
        public string UploadButtonLabel { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("uploadTiming")]
        public FileUploadTiming? UploadTiming { get; set; }
    }

    /// <summary>
    /// Form reference field configuration - embeds fields from another form
    /// </summary>
    public partial class FormRefConfig
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("fieldPrefix")]
        public string FieldPrefix { get; set; }

        [JsonPropertyName("formId")]
        public string FormId { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("showSections")]
        public bool? ShowSections { get; set; }
    }

    /// <summary>
    /// Phone field configuration
    /// </summary>
    public partial class PhoneConfig
    {
        [JsonPropertyName("countryCodes")]
        public List<CountryCodeOption> CountryCodes { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("defaultCountryCode")]
        public string DefaultCountryCode { get; set; }
    }

    /// <summary>
    /// Country code option for phone field
    /// </summary>
    public partial class CountryCodeOption
    {
        [JsonPropertyName("code")]
        public string Code { get; set; }

        [JsonPropertyName("country")]
        public string Country { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("flag")]
        public string Flag { get; set; }
    }

    /// <summary>
    /// Table field configuration
    /// </summary>
    public partial class TableConfig
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("addRowLabel")]
        public string AddRowLabel { get; set; }

        [JsonPropertyName("columns")]
        public List<TableColumnConfig> Columns { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("fixedRowCount")]
        public double? FixedRowCount { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("maxRows")]
        public double? MaxRows { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("minRows")]
        public double? MinRows { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("removeRowLabel")]
        public string RemoveRowLabel { get; set; }

        [JsonPropertyName("rowMode")]
        public TableRowMode RowMode { get; set; }
    }

    /// <summary>
    /// Table column configuration
    /// </summary>
    public partial class TableColumnConfig
    {
        [JsonPropertyName("label")]
        public string Label { get; set; }

        [JsonPropertyName("name")]
        public string Name { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("options")]
        public List<SelectOption> Options { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("placeholder")]
        public string Placeholder { get; set; }

        [JsonPropertyName("type")]
        public ColumnType Type { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("validations")]
        public List<ValidationRule> Validations { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("width")]
        public double? Width { get; set; }
    }

    /// <summary>
    /// Form section configuration
    /// </summary>
    public partial class FormSection
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("anchorId")]
        public string AnchorId { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("condition")]
        public ValidationCondition Condition { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("description")]
        public string Description { get; set; }

        [JsonPropertyName("id")]
        public string Id { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("order")]
        public double? Order { get; set; }

        [JsonPropertyName("title")]
        public string Title { get; set; }
    }

    /// <summary>
    /// Wizard mode configuration - splits form into multi-page wizard
    ///
    /// Wizard configuration settings
    /// </summary>
    public partial class WizardConfig
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("allowFreeNavigation")]
        public bool? AllowFreeNavigation { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("nextLabel")]
        public string NextLabel { get; set; }

        [JsonPropertyName("pages")]
        public List<WizardPage> Pages { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("prevLabel")]
        public string PrevLabel { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("showPageNumbers")]
        public bool? ShowPageNumbers { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("showProgressBar")]
        public bool? ShowProgressBar { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("submitLabel")]
        public string SubmitLabel { get; set; }
    }

    /// <summary>
    /// Wizard page configuration - groups sections into navigable pages
    /// </summary>
    public partial class WizardPage
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("condition")]
        public ValidationCondition Condition { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("description")]
        public string Description { get; set; }

        [JsonPropertyName("id")]
        public string Id { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("order")]
        public double? Order { get; set; }

        [JsonPropertyName("sectionIds")]
        public List<string> SectionIds { get; set; }

        [JsonPropertyName("title")]
        public string Title { get; set; }
    }

    /// <summary>
    /// Optional trigger for when validation should run
    /// - 'blur': Validate when field loses focus (default)
    /// - 'change': Validate on every change
    /// </summary>
    public enum Trigger { Blur, Change };

    /// <summary>
    /// Comparison operators for validation conditions
    /// </summary>
    public enum ValidationConditionOperator { Equals, IsEmpty, IsNotEmpty, NotEquals };

    public enum TypeEnum { Expression };

    /// <summary>
    /// Column types supported within datagrids
    ///
    /// Column types supported within tables (subset of FieldType)
    /// </summary>
    public enum ColumnType { Date, Number, Select, Text };

    /// <summary>
    /// Validation rule type
    /// </summary>
    public enum ValidationRuleType { Custom, Email, Max, MaxLength, Min, MinLength, Pattern, Required };

    /// <summary>
    /// File upload timing configuration
    /// </summary>
    public enum FileUploadTiming { Immediate, Manual };

    /// <summary>
    /// Table row mode configuration
    /// </summary>
    public enum TableRowMode { Dynamic, Fixed };

    /// <summary>
    /// Supported form field types
    /// </summary>
    public enum FieldType { Autocomplete, Checkbox, DataGrid, Date, DateRange, Email, FileUpload, FormRef, Info, Number, Phone, Radio, Select, Table, Text, Textarea };

    internal static class Converter
    {
        public static readonly JsonSerializerOptions Settings = new(JsonSerializerDefaults.General)
        {
            Converters =
            {
                TriggerConverter.Singleton,
                ValidationConditionOperatorConverter.Singleton,
                TypeEnumConverter.Singleton,
                ColumnTypeConverter.Singleton,
                ValidationRuleTypeConverter.Singleton,
                FileUploadTimingConverter.Singleton,
                TableRowModeConverter.Singleton,
                FieldTypeConverter.Singleton
            },
        };
    }

    internal class TriggerConverter : JsonConverter<Trigger>
    {
        public override bool CanConvert(Type t) => t == typeof(Trigger);

        public override Trigger Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "blur":
                    return Trigger.Blur;
                case "change":
                    return Trigger.Change;
            }
            throw new Exception("Cannot unmarshal type Trigger");
        }

        public override void Write(Utf8JsonWriter writer, Trigger value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case Trigger.Blur:
                    JsonSerializer.Serialize(writer, "blur", options);
                    return;
                case Trigger.Change:
                    JsonSerializer.Serialize(writer, "change", options);
                    return;
            }
            throw new Exception("Cannot marshal type Trigger");
        }

        public static readonly TriggerConverter Singleton = new TriggerConverter();
    }

    internal class ValidationConditionOperatorConverter : JsonConverter<ValidationConditionOperator>
    {
        public override bool CanConvert(Type t) => t == typeof(ValidationConditionOperator);

        public override ValidationConditionOperator Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "equals":
                    return ValidationConditionOperator.Equals;
                case "isEmpty":
                    return ValidationConditionOperator.IsEmpty;
                case "isNotEmpty":
                    return ValidationConditionOperator.IsNotEmpty;
                case "notEquals":
                    return ValidationConditionOperator.NotEquals;
            }
            throw new Exception("Cannot unmarshal type ValidationConditionOperator");
        }

        public override void Write(Utf8JsonWriter writer, ValidationConditionOperator value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case ValidationConditionOperator.Equals:
                    JsonSerializer.Serialize(writer, "equals", options);
                    return;
                case ValidationConditionOperator.IsEmpty:
                    JsonSerializer.Serialize(writer, "isEmpty", options);
                    return;
                case ValidationConditionOperator.IsNotEmpty:
                    JsonSerializer.Serialize(writer, "isNotEmpty", options);
                    return;
                case ValidationConditionOperator.NotEquals:
                    JsonSerializer.Serialize(writer, "notEquals", options);
                    return;
            }
            throw new Exception("Cannot marshal type ValidationConditionOperator");
        }

        public static readonly ValidationConditionOperatorConverter Singleton = new ValidationConditionOperatorConverter();
    }

    internal class TypeEnumConverter : JsonConverter<TypeEnum>
    {
        public override bool CanConvert(Type t) => t == typeof(TypeEnum);

        public override TypeEnum Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            if (value == "expression")
            {
                return TypeEnum.Expression;
            }
            throw new Exception("Cannot unmarshal type TypeEnum");
        }

        public override void Write(Utf8JsonWriter writer, TypeEnum value, JsonSerializerOptions options)
        {
            if (value == TypeEnum.Expression)
            {
                JsonSerializer.Serialize(writer, "expression", options);
                return;
            }
            throw new Exception("Cannot marshal type TypeEnum");
        }

        public static readonly TypeEnumConverter Singleton = new TypeEnumConverter();
    }

    internal class ColumnTypeConverter : JsonConverter<ColumnType>
    {
        public override bool CanConvert(Type t) => t == typeof(ColumnType);

        public override ColumnType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "date":
                    return ColumnType.Date;
                case "number":
                    return ColumnType.Number;
                case "select":
                    return ColumnType.Select;
                case "text":
                    return ColumnType.Text;
            }
            throw new Exception("Cannot unmarshal type ColumnType");
        }

        public override void Write(Utf8JsonWriter writer, ColumnType value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case ColumnType.Date:
                    JsonSerializer.Serialize(writer, "date", options);
                    return;
                case ColumnType.Number:
                    JsonSerializer.Serialize(writer, "number", options);
                    return;
                case ColumnType.Select:
                    JsonSerializer.Serialize(writer, "select", options);
                    return;
                case ColumnType.Text:
                    JsonSerializer.Serialize(writer, "text", options);
                    return;
            }
            throw new Exception("Cannot marshal type ColumnType");
        }

        public static readonly ColumnTypeConverter Singleton = new ColumnTypeConverter();
    }

    internal class ValidationRuleTypeConverter : JsonConverter<ValidationRuleType>
    {
        public override bool CanConvert(Type t) => t == typeof(ValidationRuleType);

        public override ValidationRuleType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "custom":
                    return ValidationRuleType.Custom;
                case "email":
                    return ValidationRuleType.Email;
                case "max":
                    return ValidationRuleType.Max;
                case "maxLength":
                    return ValidationRuleType.MaxLength;
                case "min":
                    return ValidationRuleType.Min;
                case "minLength":
                    return ValidationRuleType.MinLength;
                case "pattern":
                    return ValidationRuleType.Pattern;
                case "required":
                    return ValidationRuleType.Required;
            }
            throw new Exception("Cannot unmarshal type ValidationRuleType");
        }

        public override void Write(Utf8JsonWriter writer, ValidationRuleType value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case ValidationRuleType.Custom:
                    JsonSerializer.Serialize(writer, "custom", options);
                    return;
                case ValidationRuleType.Email:
                    JsonSerializer.Serialize(writer, "email", options);
                    return;
                case ValidationRuleType.Max:
                    JsonSerializer.Serialize(writer, "max", options);
                    return;
                case ValidationRuleType.MaxLength:
                    JsonSerializer.Serialize(writer, "maxLength", options);
                    return;
                case ValidationRuleType.Min:
                    JsonSerializer.Serialize(writer, "min", options);
                    return;
                case ValidationRuleType.MinLength:
                    JsonSerializer.Serialize(writer, "minLength", options);
                    return;
                case ValidationRuleType.Pattern:
                    JsonSerializer.Serialize(writer, "pattern", options);
                    return;
                case ValidationRuleType.Required:
                    JsonSerializer.Serialize(writer, "required", options);
                    return;
            }
            throw new Exception("Cannot marshal type ValidationRuleType");
        }

        public static readonly ValidationRuleTypeConverter Singleton = new ValidationRuleTypeConverter();
    }

    internal class FileUploadTimingConverter : JsonConverter<FileUploadTiming>
    {
        public override bool CanConvert(Type t) => t == typeof(FileUploadTiming);

        public override FileUploadTiming Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "immediate":
                    return FileUploadTiming.Immediate;
                case "manual":
                    return FileUploadTiming.Manual;
            }
            throw new Exception("Cannot unmarshal type FileUploadTiming");
        }

        public override void Write(Utf8JsonWriter writer, FileUploadTiming value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case FileUploadTiming.Immediate:
                    JsonSerializer.Serialize(writer, "immediate", options);
                    return;
                case FileUploadTiming.Manual:
                    JsonSerializer.Serialize(writer, "manual", options);
                    return;
            }
            throw new Exception("Cannot marshal type FileUploadTiming");
        }

        public static readonly FileUploadTimingConverter Singleton = new FileUploadTimingConverter();
    }

    internal class TableRowModeConverter : JsonConverter<TableRowMode>
    {
        public override bool CanConvert(Type t) => t == typeof(TableRowMode);

        public override TableRowMode Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "dynamic":
                    return TableRowMode.Dynamic;
                case "fixed":
                    return TableRowMode.Fixed;
            }
            throw new Exception("Cannot unmarshal type TableRowMode");
        }

        public override void Write(Utf8JsonWriter writer, TableRowMode value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case TableRowMode.Dynamic:
                    JsonSerializer.Serialize(writer, "dynamic", options);
                    return;
                case TableRowMode.Fixed:
                    JsonSerializer.Serialize(writer, "fixed", options);
                    return;
            }
            throw new Exception("Cannot marshal type TableRowMode");
        }

        public static readonly TableRowModeConverter Singleton = new TableRowModeConverter();
    }

    internal class FieldTypeConverter : JsonConverter<FieldType>
    {
        public override bool CanConvert(Type t) => t == typeof(FieldType);

        public override FieldType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "autocomplete":
                    return FieldType.Autocomplete;
                case "checkbox":
                    return FieldType.Checkbox;
                case "datagrid":
                    return FieldType.DataGrid;
                case "date":
                    return FieldType.Date;
                case "daterange":
                    return FieldType.DateRange;
                case "email":
                    return FieldType.Email;
                case "fileupload":
                    return FieldType.FileUpload;
                case "formref":
                    return FieldType.FormRef;
                case "info":
                    return FieldType.Info;
                case "number":
                    return FieldType.Number;
                case "phone":
                    return FieldType.Phone;
                case "radio":
                    return FieldType.Radio;
                case "select":
                    return FieldType.Select;
                case "table":
                    return FieldType.Table;
                case "text":
                    return FieldType.Text;
                case "textarea":
                    return FieldType.Textarea;
            }
            throw new Exception("Cannot unmarshal type FieldType");
        }

        public override void Write(Utf8JsonWriter writer, FieldType value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case FieldType.Autocomplete:
                    JsonSerializer.Serialize(writer, "autocomplete", options);
                    return;
                case FieldType.Checkbox:
                    JsonSerializer.Serialize(writer, "checkbox", options);
                    return;
                case FieldType.DataGrid:
                    JsonSerializer.Serialize(writer, "datagrid", options);
                    return;
                case FieldType.Date:
                    JsonSerializer.Serialize(writer, "date", options);
                    return;
                case FieldType.DateRange:
                    JsonSerializer.Serialize(writer, "daterange", options);
                    return;
                case FieldType.Email:
                    JsonSerializer.Serialize(writer, "email", options);
                    return;
                case FieldType.FileUpload:
                    JsonSerializer.Serialize(writer, "fileupload", options);
                    return;
                case FieldType.FormRef:
                    JsonSerializer.Serialize(writer, "formref", options);
                    return;
                case FieldType.Info:
                    JsonSerializer.Serialize(writer, "info", options);
                    return;
                case FieldType.Number:
                    JsonSerializer.Serialize(writer, "number", options);
                    return;
                case FieldType.Phone:
                    JsonSerializer.Serialize(writer, "phone", options);
                    return;
                case FieldType.Radio:
                    JsonSerializer.Serialize(writer, "radio", options);
                    return;
                case FieldType.Select:
                    JsonSerializer.Serialize(writer, "select", options);
                    return;
                case FieldType.Table:
                    JsonSerializer.Serialize(writer, "table", options);
                    return;
                case FieldType.Text:
                    JsonSerializer.Serialize(writer, "text", options);
                    return;
                case FieldType.Textarea:
                    JsonSerializer.Serialize(writer, "textarea", options);
                    return;
            }
            throw new Exception("Cannot marshal type FieldType");
        }

        public static readonly FieldTypeConverter Singleton = new FieldTypeConverter();
    }
    

}
